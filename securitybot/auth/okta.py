'''
Authentication using Okta.
'''
import pytz

__author__ = 'Chandler Newby'
__email__ = 'chandler.newby@gmail.com'

import logging
import requests
import json
from datetime import datetime
from securitybot.auth.auth import Auth, AUTH_STATES, AUTH_TIME


class OktaAuth(Auth):
    API_BASE = '/api/v1/'
    HEADERS = {'Accept': 'application/json',
               'Content-Type': 'application/json'}

    def __init__(self, okta_api_key, okta_api_endpoint, username):
        # type: (Any, str) -> None
        '''
        Args:
            okta_api_key (str): The api token generated by Okta.
            okta_api_endpoint (str): The full okta URL (https://myorg.okta.com).
            username (str): The username of the person authorized through
                            this object.
        '''
        self.endpoint = okta_api_endpoint
        self.token = okta_api_key
        self.username = username
        self.okta_user_id = None
        self.okta_push_factor_id = None
        self.poll_url = None
        self.headers = self.HEADERS
        self.headers.update({'Authorization': 'SSWS %s' % self.token})

        self.auth_time = datetime.min
        self.state = AUTH_STATES.NONE

    def _make_get_request(self, path, queryParameters=None, additional_headers=None):
        if not path.startswith('http'):
            path = self.endpoint + self.API_BASE + path
        request_headers = self.headers
        if additional_headers:
            request_headers.update(additional_headers)

        r = requests.get(path, params=queryParameters, headers=request_headers)
        return r.json()

    def _make_post_request(self, path, data=None, additional_headers=None):
        if not path.startswith('http'):
            path = self.endpoint + self.API_BASE + path
        request_headers = self.headers
        if additional_headers:
            request_headers.update(additional_headers)

        if data:
            data = json.dumps(data, separators=(',', ':'))

        r = requests.post(path, data=data, headers=request_headers)
        return r.json()

    def _get_okta_userid(self, username):
        r = self._make_get_request('users', queryParameters={'q': username})
        try:
            return r[0]['id']
        except:
            return None

    def _get_factors(self, userid):
        return self._make_get_request('users/%s/factors' % userid)

    def can_auth(self):
        # type: () -> bool
        # Check Okta user for a push factor.
        # TODO: Add support for other types of auth (TOTP, etc).
        logging.debug('Checking auth capabilities for {}'.format(self.username))

        self.okta_user_id = self._get_okta_userid(self.username)
        factors = self._get_factors(self.okta_user_id)
        for factor in factors:
            if factor['factorType'] == 'push':
                self.okta_push_factor_id = factor['id']
                return True

        return False

    def auth(self, reason=None):
        # type: (str) -> None
        logging.debug('Sending Okta Push request for {}'.format(self.username))

        res = self._make_post_request('users/%s/factors/%s/verify' % (self.okta_user_id, self.okta_push_factor_id))
        self.poll_url = res['_links']['poll']['href']
        self.state = AUTH_STATES.PENDING

    def _recently_authed(self):
        # type: () -> bool
        return (datetime.now(tz=pytz.utc) - self.auth_time) < AUTH_TIME

    def auth_status(self):
        # type: () -> int
        if self.state == AUTH_STATES.PENDING:
            response = self._make_get_request(self.poll_url)
            res = response['factorResult']
            if not res['WAITING']:
                if res['SUCCESS']:
                    self.state = AUTH_STATES.AUTHORIZED
                    self.auth_time = datetime.now(tz=pytz.utc)
                else:
                    self.state = AUTH_STATES.DENIED
                    self.auth_time = datetime.min
        elif self.state == AUTH_STATES.AUTHORIZED:
            if not self._recently_authed():
                self.state = AUTH_STATES.NONE
        return self.state

    def reset(self):
        # type: () -> None
        self.poll_url = None
        self.state = AUTH_STATES.NONE
